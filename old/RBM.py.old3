#!/usr/bin/python
import numpy as np
from scipy import optimize
import sys
import random
'''
RBM	: Restricted Boltzman Machine.
Es un tipo de Red Neural Artificail (ANN) que desifra patrones por su cuenta sin supervision
'''
class RBM(object):
	def __init__(self, visibleSize=2, hiddenSize=3):
		self.visibleLayerSize = visibleSize
		self.hiddenLayerSize = hiddenSize
		#self.K = 0.001*(13./8.)
		#self.K = 0.001*(13./8.)
		self.K = 0.001*(34./21.)
		weights = np.zeros((self.hiddenLayerSize, self.visibleLayerSize))
		for i in xrange(hiddenSize):
			for j in xrange(visibleSize):
				value = random.uniform(-(0.2+self.K),0.2+self.K)
				weights[i][j] = value
		self.Weights = weights
		C = np.zeros((self.visibleLayerSize,1))
		for n in xrange(self.visibleLayerSize):
			p = (n*1.)/(self.visibleLayerSize*1.)
			C[n] = np.log(p/(1.-p))
		self.visibleBias = C
		K = np.zeros((self.hiddenLayerSize,1))
		self.hiddenBias = K

	def sigmoid(self, z):
		return 1/(1+np.exp(-z))	

	def getParams(self):
		params = self.Weights.ravel()
		return params

	def setParams(self, params):
		hb, vb, w = params
		self.Weights = np.reshape(w, (self.hiddenLayerSize, self.visibleLayerSize))
		self.hiddenBias = np.reshape(hb, (self.hiddenLayerSize, 1))
		self.visibleBias = np.reshape(vb, (self.visibleLayerSize, 1))

	def check(self, X):
		h1 = np.zeros((self.hiddenLayerSize,1));
		for j in xrange(self.hiddenLayerSize):
			sumation = 0
			for i in xrange(self.visibleLayerSize):
				sumation += X[i]*self.Weights[j][i]
			h1[j] = self.sigmoid( self.hiddenBias[j] + sumation )
		v2 = np.zeros((self.visibleLayerSize,1));
		for i in xrange(self.visibleLayerSize):
			sumation = 0
			for j in xrange(self.hiddenLayerSize):
				sumation += h1[j]*self.Weights[j][i]
			v2[i] = self.sigmoid( self.visibleBias[i] + sumation )
		return v2

	def trainNetwork(self,V, dbh, batch_size=10):
		c = 0
		total = len(V)
		for v in V:
			v = v.reshape((self.visibleLayerSize,1))
			c += 1
			print "Elemento",c,"de",total
			rate = self.K*10.
			deltaWeight = np.zeros(self.Weights.shape)
			deltaHBias = np.zeros(self.hiddenBias.shape)
			deltaVBias = np.zeros(self.visibleBias.shape)
			h1 = np.zeros((self.hiddenLayerSize,1))
			for j in xrange(self.hiddenLayerSize):
				sumation = 0
				for i in xrange(self.visibleLayerSize):
					sumation += v[i]*self.Weights[j][i]
				h1[j] = self.sigmoid( self.hiddenBias[j] + sumation )
			v2 = np.zeros((self.visibleLayerSize,1))
			for i in xrange(self.visibleLayerSize):
				sumation = 0
				for j in xrange(self.hiddenLayerSize):
					sumation += h1[j]*self.Weights[j][i]
				v2[i] = self.sigmoid( self.visibleBias[i] + sumation )
			h2 = np.zeros((self.hiddenLayerSize,1))
			for j in xrange(self.hiddenLayerSize):
				sumation = 1
				for i in xrange(self.visibleLayerSize):
					sumation += v2[i]*self.Weights[j][i]
				h2[j] = self.sigmoid( self.hiddenBias[j] + sumation )
			deltaWeight = rate*(np.outer(h1,v)-np.outer(h2,v2))
			deltaHBias = rate*(h1-h2)
			deltaVBias = rate*(v-v2)
			self.Weights += deltaWeight
			self.hiddenBias += deltaHBias
			self.visibleBias += deltaVBias 
			if c%10==0:
				print "actualizando peso"
				upd = dbh.query("UPDATE weight SET weight=?, hiddenBias=?, visibleBias=? WHERE layer='Layer One';",(self.getParams(), self.hiddenBias.ravel(), self.visibleBias.ravel(),))
		print "actualizando peso"
		upd = dbh.query("UPDATE weight SET weight=?, hiddenBias=?, visibleBias=? WHERE layer='Layer One';",(self.getParams(), self.hiddenBias.ravel(), self.visibleBias.ravel(),))
		#upd = dbh.query("UPDATE weight SET weight=? WHERE layer='Layer One';",(self.getParams(),))

	def bernoulli(self,p):
		b = np.random.rand(*p.shape) < p
		return np.array(b, dtype=float)
